// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"gopan-server/ent/filehash"
	"gopan-server/ent/node"
	"gopan-server/ent/predicate"
	"gopan-server/ent/share"
	"gopan-server/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFileHash = "FileHash"
	TypeNode     = "Node"
	TypeShare    = "Share"
	TypeUser     = "User"
)

// FileHashMutation represents an operation that mutates the FileHash nodes in the graph.
type FileHashMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	hash               *string
	minio_object       *string
	size               *int64
	addsize            *int64
	mime_type          *string
	reference_count    *int
	addreference_count *int
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*FileHash, error)
	predicates         []predicate.FileHash
}

var _ ent.Mutation = (*FileHashMutation)(nil)

// filehashOption allows management of the mutation configuration using functional options.
type filehashOption func(*FileHashMutation)

// newFileHashMutation creates new mutation for the FileHash entity.
func newFileHashMutation(c config, op Op, opts ...filehashOption) *FileHashMutation {
	m := &FileHashMutation{
		config:        c,
		op:            op,
		typ:           TypeFileHash,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileHashID sets the ID field of the mutation.
func withFileHashID(id int) filehashOption {
	return func(m *FileHashMutation) {
		var (
			err   error
			once  sync.Once
			value *FileHash
		)
		m.oldValue = func(ctx context.Context) (*FileHash, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FileHash.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileHash sets the old FileHash of the mutation.
func withFileHash(node *FileHash) filehashOption {
	return func(m *FileHashMutation) {
		m.oldValue = func(context.Context) (*FileHash, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileHashMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileHashMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileHashMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileHashMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FileHash.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *FileHashMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *FileHashMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *FileHashMutation) ResetHash() {
	m.hash = nil
}

// SetMinioObject sets the "minio_object" field.
func (m *FileHashMutation) SetMinioObject(s string) {
	m.minio_object = &s
}

// MinioObject returns the value of the "minio_object" field in the mutation.
func (m *FileHashMutation) MinioObject() (r string, exists bool) {
	v := m.minio_object
	if v == nil {
		return
	}
	return *v, true
}

// OldMinioObject returns the old "minio_object" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldMinioObject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinioObject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinioObject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinioObject: %w", err)
	}
	return oldValue.MinioObject, nil
}

// ResetMinioObject resets all changes to the "minio_object" field.
func (m *FileHashMutation) ResetMinioObject() {
	m.minio_object = nil
}

// SetSize sets the "size" field.
func (m *FileHashMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileHashMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileHashMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileHashMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileHashMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMimeType sets the "mime_type" field.
func (m *FileHashMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *FileHashMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *FileHashMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[filehash.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *FileHashMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[filehash.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *FileHashMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, filehash.FieldMimeType)
}

// SetReferenceCount sets the "reference_count" field.
func (m *FileHashMutation) SetReferenceCount(i int) {
	m.reference_count = &i
	m.addreference_count = nil
}

// ReferenceCount returns the value of the "reference_count" field in the mutation.
func (m *FileHashMutation) ReferenceCount() (r int, exists bool) {
	v := m.reference_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceCount returns the old "reference_count" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldReferenceCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceCount: %w", err)
	}
	return oldValue.ReferenceCount, nil
}

// AddReferenceCount adds i to the "reference_count" field.
func (m *FileHashMutation) AddReferenceCount(i int) {
	if m.addreference_count != nil {
		*m.addreference_count += i
	} else {
		m.addreference_count = &i
	}
}

// AddedReferenceCount returns the value that was added to the "reference_count" field in this mutation.
func (m *FileHashMutation) AddedReferenceCount() (r int, exists bool) {
	v := m.addreference_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferenceCount resets all changes to the "reference_count" field.
func (m *FileHashMutation) ResetReferenceCount() {
	m.reference_count = nil
	m.addreference_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileHashMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileHashMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileHashMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileHashMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileHashMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FileHash entity.
// If the FileHash object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileHashMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileHashMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the FileHashMutation builder.
func (m *FileHashMutation) Where(ps ...predicate.FileHash) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileHashMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileHashMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FileHash, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileHashMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileHashMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FileHash).
func (m *FileHashMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileHashMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.hash != nil {
		fields = append(fields, filehash.FieldHash)
	}
	if m.minio_object != nil {
		fields = append(fields, filehash.FieldMinioObject)
	}
	if m.size != nil {
		fields = append(fields, filehash.FieldSize)
	}
	if m.mime_type != nil {
		fields = append(fields, filehash.FieldMimeType)
	}
	if m.reference_count != nil {
		fields = append(fields, filehash.FieldReferenceCount)
	}
	if m.created_at != nil {
		fields = append(fields, filehash.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, filehash.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileHashMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filehash.FieldHash:
		return m.Hash()
	case filehash.FieldMinioObject:
		return m.MinioObject()
	case filehash.FieldSize:
		return m.Size()
	case filehash.FieldMimeType:
		return m.MimeType()
	case filehash.FieldReferenceCount:
		return m.ReferenceCount()
	case filehash.FieldCreatedAt:
		return m.CreatedAt()
	case filehash.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileHashMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filehash.FieldHash:
		return m.OldHash(ctx)
	case filehash.FieldMinioObject:
		return m.OldMinioObject(ctx)
	case filehash.FieldSize:
		return m.OldSize(ctx)
	case filehash.FieldMimeType:
		return m.OldMimeType(ctx)
	case filehash.FieldReferenceCount:
		return m.OldReferenceCount(ctx)
	case filehash.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case filehash.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FileHash field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHashMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filehash.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case filehash.FieldMinioObject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinioObject(v)
		return nil
	case filehash.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case filehash.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case filehash.FieldReferenceCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceCount(v)
		return nil
	case filehash.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case filehash.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FileHash field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileHashMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, filehash.FieldSize)
	}
	if m.addreference_count != nil {
		fields = append(fields, filehash.FieldReferenceCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileHashMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filehash.FieldSize:
		return m.AddedSize()
	case filehash.FieldReferenceCount:
		return m.AddedReferenceCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileHashMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filehash.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case filehash.FieldReferenceCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferenceCount(v)
		return nil
	}
	return fmt.Errorf("unknown FileHash numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileHashMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filehash.FieldMimeType) {
		fields = append(fields, filehash.FieldMimeType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileHashMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileHashMutation) ClearField(name string) error {
	switch name {
	case filehash.FieldMimeType:
		m.ClearMimeType()
		return nil
	}
	return fmt.Errorf("unknown FileHash nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileHashMutation) ResetField(name string) error {
	switch name {
	case filehash.FieldHash:
		m.ResetHash()
		return nil
	case filehash.FieldMinioObject:
		m.ResetMinioObject()
		return nil
	case filehash.FieldSize:
		m.ResetSize()
		return nil
	case filehash.FieldMimeType:
		m.ResetMimeType()
		return nil
	case filehash.FieldReferenceCount:
		m.ResetReferenceCount()
		return nil
	case filehash.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case filehash.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FileHash field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileHashMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileHashMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileHashMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileHashMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileHashMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileHashMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileHashMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FileHash unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileHashMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FileHash edge %s", name)
}

// NodeMutation represents an operation that mutates the Node nodes in the graph.
type NodeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	_type           *int
	add_type        *int
	size            *int64
	addsize         *int64
	mime_type       *string
	file_hash       *string
	minio_object    *string
	is_deleted      *bool
	deleted_at      *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	owner           *int
	clearedowner    bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	shares          map[int]struct{}
	removedshares   map[int]struct{}
	clearedshares   bool
	done            bool
	oldValue        func(context.Context) (*Node, error)
	predicates      []predicate.Node
}

var _ ent.Mutation = (*NodeMutation)(nil)

// nodeOption allows management of the mutation configuration using functional options.
type nodeOption func(*NodeMutation)

// newNodeMutation creates new mutation for the Node entity.
func newNodeMutation(c config, op Op, opts ...nodeOption) *NodeMutation {
	m := &NodeMutation{
		config:        c,
		op:            op,
		typ:           TypeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNodeID sets the ID field of the mutation.
func withNodeID(id int) nodeOption {
	return func(m *NodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Node
		)
		m.oldValue = func(ctx context.Context) (*Node, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Node.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNode sets the old Node of the mutation.
func withNode(node *Node) nodeOption {
	return func(m *NodeMutation) {
		m.oldValue = func(context.Context) (*Node, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Node.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NodeMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *NodeMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *NodeMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *NodeMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *NodeMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *NodeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetSize sets the "size" field.
func (m *NodeMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *NodeMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *NodeMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *NodeMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *NodeMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMimeType sets the "mime_type" field.
func (m *NodeMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *NodeMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *NodeMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[node.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *NodeMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[node.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *NodeMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, node.FieldMimeType)
}

// SetFileHash sets the "file_hash" field.
func (m *NodeMutation) SetFileHash(s string) {
	m.file_hash = &s
}

// FileHash returns the value of the "file_hash" field in the mutation.
func (m *NodeMutation) FileHash() (r string, exists bool) {
	v := m.file_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFileHash returns the old "file_hash" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldFileHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileHash: %w", err)
	}
	return oldValue.FileHash, nil
}

// ClearFileHash clears the value of the "file_hash" field.
func (m *NodeMutation) ClearFileHash() {
	m.file_hash = nil
	m.clearedFields[node.FieldFileHash] = struct{}{}
}

// FileHashCleared returns if the "file_hash" field was cleared in this mutation.
func (m *NodeMutation) FileHashCleared() bool {
	_, ok := m.clearedFields[node.FieldFileHash]
	return ok
}

// ResetFileHash resets all changes to the "file_hash" field.
func (m *NodeMutation) ResetFileHash() {
	m.file_hash = nil
	delete(m.clearedFields, node.FieldFileHash)
}

// SetMinioObject sets the "minio_object" field.
func (m *NodeMutation) SetMinioObject(s string) {
	m.minio_object = &s
}

// MinioObject returns the value of the "minio_object" field in the mutation.
func (m *NodeMutation) MinioObject() (r string, exists bool) {
	v := m.minio_object
	if v == nil {
		return
	}
	return *v, true
}

// OldMinioObject returns the old "minio_object" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldMinioObject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinioObject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinioObject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinioObject: %w", err)
	}
	return oldValue.MinioObject, nil
}

// ClearMinioObject clears the value of the "minio_object" field.
func (m *NodeMutation) ClearMinioObject() {
	m.minio_object = nil
	m.clearedFields[node.FieldMinioObject] = struct{}{}
}

// MinioObjectCleared returns if the "minio_object" field was cleared in this mutation.
func (m *NodeMutation) MinioObjectCleared() bool {
	_, ok := m.clearedFields[node.FieldMinioObject]
	return ok
}

// ResetMinioObject resets all changes to the "minio_object" field.
func (m *NodeMutation) ResetMinioObject() {
	m.minio_object = nil
	delete(m.clearedFields, node.FieldMinioObject)
}

// SetIsDeleted sets the "is_deleted" field.
func (m *NodeMutation) SetIsDeleted(b bool) {
	m.is_deleted = &b
}

// IsDeleted returns the value of the "is_deleted" field in the mutation.
func (m *NodeMutation) IsDeleted() (r bool, exists bool) {
	v := m.is_deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "is_deleted" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ResetIsDeleted resets all changes to the "is_deleted" field.
func (m *NodeMutation) ResetIsDeleted() {
	m.is_deleted = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NodeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NodeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NodeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[node.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NodeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[node.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NodeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, node.FieldDeletedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *NodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Node entity.
// If the Node object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NodeMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NodeMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NodeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NodeMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NodeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetParentID sets the "parent" edge to the Node entity by id.
func (m *NodeMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Node entity.
func (m *NodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Node entity was cleared.
func (m *NodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *NodeMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *NodeMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *NodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Node entity by ids.
func (m *NodeMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Node entity.
func (m *NodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Node entity was cleared.
func (m *NodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Node entity by IDs.
func (m *NodeMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Node entity.
func (m *NodeMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *NodeMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *NodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *NodeMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *NodeMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *NodeMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *NodeMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *NodeMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *NodeMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *NodeMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// Where appends a list predicates to the NodeMutation builder.
func (m *NodeMutation) Where(ps ...predicate.Node) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Node, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Node).
func (m *NodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name != nil {
		fields = append(fields, node.FieldName)
	}
	if m._type != nil {
		fields = append(fields, node.FieldType)
	}
	if m.size != nil {
		fields = append(fields, node.FieldSize)
	}
	if m.mime_type != nil {
		fields = append(fields, node.FieldMimeType)
	}
	if m.file_hash != nil {
		fields = append(fields, node.FieldFileHash)
	}
	if m.minio_object != nil {
		fields = append(fields, node.FieldMinioObject)
	}
	if m.is_deleted != nil {
		fields = append(fields, node.FieldIsDeleted)
	}
	if m.deleted_at != nil {
		fields = append(fields, node.FieldDeletedAt)
	}
	if m.created_at != nil {
		fields = append(fields, node.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, node.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case node.FieldName:
		return m.Name()
	case node.FieldType:
		return m.GetType()
	case node.FieldSize:
		return m.Size()
	case node.FieldMimeType:
		return m.MimeType()
	case node.FieldFileHash:
		return m.FileHash()
	case node.FieldMinioObject:
		return m.MinioObject()
	case node.FieldIsDeleted:
		return m.IsDeleted()
	case node.FieldDeletedAt:
		return m.DeletedAt()
	case node.FieldCreatedAt:
		return m.CreatedAt()
	case node.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case node.FieldName:
		return m.OldName(ctx)
	case node.FieldType:
		return m.OldType(ctx)
	case node.FieldSize:
		return m.OldSize(ctx)
	case node.FieldMimeType:
		return m.OldMimeType(ctx)
	case node.FieldFileHash:
		return m.OldFileHash(ctx)
	case node.FieldMinioObject:
		return m.OldMinioObject(ctx)
	case node.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case node.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case node.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case node.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Node field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case node.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case node.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case node.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case node.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case node.FieldFileHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileHash(v)
		return nil
	case node.FieldMinioObject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinioObject(v)
		return nil
	case node.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case node.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case node.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case node.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NodeMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, node.FieldType)
	}
	if m.addsize != nil {
		fields = append(fields, node.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case node.FieldType:
		return m.AddedType()
	case node.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case node.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case node.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Node numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(node.FieldMimeType) {
		fields = append(fields, node.FieldMimeType)
	}
	if m.FieldCleared(node.FieldFileHash) {
		fields = append(fields, node.FieldFileHash)
	}
	if m.FieldCleared(node.FieldMinioObject) {
		fields = append(fields, node.FieldMinioObject)
	}
	if m.FieldCleared(node.FieldDeletedAt) {
		fields = append(fields, node.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NodeMutation) ClearField(name string) error {
	switch name {
	case node.FieldMimeType:
		m.ClearMimeType()
		return nil
	case node.FieldFileHash:
		m.ClearFileHash()
		return nil
	case node.FieldMinioObject:
		m.ClearMinioObject()
		return nil
	case node.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Node nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NodeMutation) ResetField(name string) error {
	switch name {
	case node.FieldName:
		m.ResetName()
		return nil
	case node.FieldType:
		m.ResetType()
		return nil
	case node.FieldSize:
		m.ResetSize()
		return nil
	case node.FieldMimeType:
		m.ResetMimeType()
		return nil
	case node.FieldFileHash:
		m.ResetFileHash()
		return nil
	case node.FieldMinioObject:
		m.ResetMinioObject()
		return nil
	case node.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case node.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case node.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case node.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Node field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, node.EdgeOwner)
	}
	if m.parent != nil {
		edges = append(edges, node.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, node.EdgeChildren)
	}
	if m.shares != nil {
		edges = append(edges, node.EdgeShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case node.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, node.EdgeChildren)
	}
	if m.removedshares != nil {
		edges = append(edges, node.EdgeShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case node.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case node.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, node.EdgeOwner)
	}
	if m.clearedparent {
		edges = append(edges, node.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, node.EdgeChildren)
	}
	if m.clearedshares {
		edges = append(edges, node.EdgeShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NodeMutation) EdgeCleared(name string) bool {
	switch name {
	case node.EdgeOwner:
		return m.clearedowner
	case node.EdgeParent:
		return m.clearedparent
	case node.EdgeChildren:
		return m.clearedchildren
	case node.EdgeShares:
		return m.clearedshares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NodeMutation) ClearEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ClearOwner()
		return nil
	case node.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Node unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NodeMutation) ResetEdge(name string) error {
	switch name {
	case node.EdgeOwner:
		m.ResetOwner()
		return nil
	case node.EdgeParent:
		m.ResetParent()
		return nil
	case node.EdgeChildren:
		m.ResetChildren()
		return nil
	case node.EdgeShares:
		m.ResetShares()
		return nil
	}
	return fmt.Errorf("unknown Node edge %s", name)
}

// ShareMutation represents an operation that mutates the Share nodes in the graph.
type ShareMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	code                *string
	share_type          *int
	addshare_type       *int
	expires_at          *time.Time
	password            *string
	access_count        *int
	addaccess_count     *int
	max_access_count    *int
	addmax_access_count *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	node                *int
	clearednode         bool
	done                bool
	oldValue            func(context.Context) (*Share, error)
	predicates          []predicate.Share
}

var _ ent.Mutation = (*ShareMutation)(nil)

// shareOption allows management of the mutation configuration using functional options.
type shareOption func(*ShareMutation)

// newShareMutation creates new mutation for the Share entity.
func newShareMutation(c config, op Op, opts ...shareOption) *ShareMutation {
	m := &ShareMutation{
		config:        c,
		op:            op,
		typ:           TypeShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShareID sets the ID field of the mutation.
func withShareID(id int) shareOption {
	return func(m *ShareMutation) {
		var (
			err   error
			once  sync.Once
			value *Share
		)
		m.oldValue = func(ctx context.Context) (*Share, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Share.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShare sets the old Share of the mutation.
func withShare(node *Share) shareOption {
	return func(m *ShareMutation) {
		m.oldValue = func(context.Context) (*Share, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShareMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShareMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Share.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *ShareMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ShareMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ShareMutation) ResetCode() {
	m.code = nil
}

// SetShareType sets the "share_type" field.
func (m *ShareMutation) SetShareType(i int) {
	m.share_type = &i
	m.addshare_type = nil
}

// ShareType returns the value of the "share_type" field in the mutation.
func (m *ShareMutation) ShareType() (r int, exists bool) {
	v := m.share_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShareType returns the old "share_type" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldShareType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareType: %w", err)
	}
	return oldValue.ShareType, nil
}

// AddShareType adds i to the "share_type" field.
func (m *ShareMutation) AddShareType(i int) {
	if m.addshare_type != nil {
		*m.addshare_type += i
	} else {
		m.addshare_type = &i
	}
}

// AddedShareType returns the value that was added to the "share_type" field in this mutation.
func (m *ShareMutation) AddedShareType() (r int, exists bool) {
	v := m.addshare_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetShareType resets all changes to the "share_type" field.
func (m *ShareMutation) ResetShareType() {
	m.share_type = nil
	m.addshare_type = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *ShareMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ShareMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ShareMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[share.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ShareMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[share.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ShareMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, share.FieldExpiresAt)
}

// SetPassword sets the "password" field.
func (m *ShareMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ShareMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *ShareMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[share.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *ShareMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[share.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *ShareMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, share.FieldPassword)
}

// SetAccessCount sets the "access_count" field.
func (m *ShareMutation) SetAccessCount(i int) {
	m.access_count = &i
	m.addaccess_count = nil
}

// AccessCount returns the value of the "access_count" field in the mutation.
func (m *ShareMutation) AccessCount() (r int, exists bool) {
	v := m.access_count
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessCount returns the old "access_count" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldAccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessCount: %w", err)
	}
	return oldValue.AccessCount, nil
}

// AddAccessCount adds i to the "access_count" field.
func (m *ShareMutation) AddAccessCount(i int) {
	if m.addaccess_count != nil {
		*m.addaccess_count += i
	} else {
		m.addaccess_count = &i
	}
}

// AddedAccessCount returns the value that was added to the "access_count" field in this mutation.
func (m *ShareMutation) AddedAccessCount() (r int, exists bool) {
	v := m.addaccess_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccessCount resets all changes to the "access_count" field.
func (m *ShareMutation) ResetAccessCount() {
	m.access_count = nil
	m.addaccess_count = nil
}

// SetMaxAccessCount sets the "max_access_count" field.
func (m *ShareMutation) SetMaxAccessCount(i int) {
	m.max_access_count = &i
	m.addmax_access_count = nil
}

// MaxAccessCount returns the value of the "max_access_count" field in the mutation.
func (m *ShareMutation) MaxAccessCount() (r int, exists bool) {
	v := m.max_access_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAccessCount returns the old "max_access_count" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldMaxAccessCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAccessCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAccessCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAccessCount: %w", err)
	}
	return oldValue.MaxAccessCount, nil
}

// AddMaxAccessCount adds i to the "max_access_count" field.
func (m *ShareMutation) AddMaxAccessCount(i int) {
	if m.addmax_access_count != nil {
		*m.addmax_access_count += i
	} else {
		m.addmax_access_count = &i
	}
}

// AddedMaxAccessCount returns the value that was added to the "max_access_count" field in this mutation.
func (m *ShareMutation) AddedMaxAccessCount() (r int, exists bool) {
	v := m.addmax_access_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxAccessCount clears the value of the "max_access_count" field.
func (m *ShareMutation) ClearMaxAccessCount() {
	m.max_access_count = nil
	m.addmax_access_count = nil
	m.clearedFields[share.FieldMaxAccessCount] = struct{}{}
}

// MaxAccessCountCleared returns if the "max_access_count" field was cleared in this mutation.
func (m *ShareMutation) MaxAccessCountCleared() bool {
	_, ok := m.clearedFields[share.FieldMaxAccessCount]
	return ok
}

// ResetMaxAccessCount resets all changes to the "max_access_count" field.
func (m *ShareMutation) ResetMaxAccessCount() {
	m.max_access_count = nil
	m.addmax_access_count = nil
	delete(m.clearedFields, share.FieldMaxAccessCount)
}

// SetCreatedAt sets the "created_at" field.
func (m *ShareMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShareMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShareMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShareMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShareMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Share entity.
// If the Share object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShareMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShareMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ShareMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ShareMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ShareMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ShareMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ShareMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetNodeID sets the "node" edge to the Node entity by id.
func (m *ShareMutation) SetNodeID(id int) {
	m.node = &id
}

// ClearNode clears the "node" edge to the Node entity.
func (m *ShareMutation) ClearNode() {
	m.clearednode = true
}

// NodeCleared reports if the "node" edge to the Node entity was cleared.
func (m *ShareMutation) NodeCleared() bool {
	return m.clearednode
}

// NodeID returns the "node" edge ID in the mutation.
func (m *ShareMutation) NodeID() (id int, exists bool) {
	if m.node != nil {
		return *m.node, true
	}
	return
}

// NodeIDs returns the "node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NodeID instead. It exists only for internal usage by the builders.
func (m *ShareMutation) NodeIDs() (ids []int) {
	if id := m.node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNode resets all changes to the "node" edge.
func (m *ShareMutation) ResetNode() {
	m.node = nil
	m.clearednode = false
}

// Where appends a list predicates to the ShareMutation builder.
func (m *ShareMutation) Where(ps ...predicate.Share) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Share, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Share).
func (m *ShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShareMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.code != nil {
		fields = append(fields, share.FieldCode)
	}
	if m.share_type != nil {
		fields = append(fields, share.FieldShareType)
	}
	if m.expires_at != nil {
		fields = append(fields, share.FieldExpiresAt)
	}
	if m.password != nil {
		fields = append(fields, share.FieldPassword)
	}
	if m.access_count != nil {
		fields = append(fields, share.FieldAccessCount)
	}
	if m.max_access_count != nil {
		fields = append(fields, share.FieldMaxAccessCount)
	}
	if m.created_at != nil {
		fields = append(fields, share.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, share.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case share.FieldCode:
		return m.Code()
	case share.FieldShareType:
		return m.ShareType()
	case share.FieldExpiresAt:
		return m.ExpiresAt()
	case share.FieldPassword:
		return m.Password()
	case share.FieldAccessCount:
		return m.AccessCount()
	case share.FieldMaxAccessCount:
		return m.MaxAccessCount()
	case share.FieldCreatedAt:
		return m.CreatedAt()
	case share.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case share.FieldCode:
		return m.OldCode(ctx)
	case share.FieldShareType:
		return m.OldShareType(ctx)
	case share.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case share.FieldPassword:
		return m.OldPassword(ctx)
	case share.FieldAccessCount:
		return m.OldAccessCount(ctx)
	case share.FieldMaxAccessCount:
		return m.OldMaxAccessCount(ctx)
	case share.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case share.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Share field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case share.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case share.FieldShareType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareType(v)
		return nil
	case share.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case share.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case share.FieldAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessCount(v)
		return nil
	case share.FieldMaxAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAccessCount(v)
		return nil
	case share.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case share.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShareMutation) AddedFields() []string {
	var fields []string
	if m.addshare_type != nil {
		fields = append(fields, share.FieldShareType)
	}
	if m.addaccess_count != nil {
		fields = append(fields, share.FieldAccessCount)
	}
	if m.addmax_access_count != nil {
		fields = append(fields, share.FieldMaxAccessCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case share.FieldShareType:
		return m.AddedShareType()
	case share.FieldAccessCount:
		return m.AddedAccessCount()
	case share.FieldMaxAccessCount:
		return m.AddedMaxAccessCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case share.FieldShareType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddShareType(v)
		return nil
	case share.FieldAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccessCount(v)
		return nil
	case share.FieldMaxAccessCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAccessCount(v)
		return nil
	}
	return fmt.Errorf("unknown Share numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShareMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(share.FieldExpiresAt) {
		fields = append(fields, share.FieldExpiresAt)
	}
	if m.FieldCleared(share.FieldPassword) {
		fields = append(fields, share.FieldPassword)
	}
	if m.FieldCleared(share.FieldMaxAccessCount) {
		fields = append(fields, share.FieldMaxAccessCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShareMutation) ClearField(name string) error {
	switch name {
	case share.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case share.FieldPassword:
		m.ClearPassword()
		return nil
	case share.FieldMaxAccessCount:
		m.ClearMaxAccessCount()
		return nil
	}
	return fmt.Errorf("unknown Share nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShareMutation) ResetField(name string) error {
	switch name {
	case share.FieldCode:
		m.ResetCode()
		return nil
	case share.FieldShareType:
		m.ResetShareType()
		return nil
	case share.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case share.FieldPassword:
		m.ResetPassword()
		return nil
	case share.FieldAccessCount:
		m.ResetAccessCount()
		return nil
	case share.FieldMaxAccessCount:
		m.ResetMaxAccessCount()
		return nil
	case share.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case share.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Share field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, share.EdgeOwner)
	}
	if m.node != nil {
		edges = append(edges, share.EdgeNode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case share.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case share.EdgeNode:
		if id := m.node; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, share.EdgeOwner)
	}
	if m.clearednode {
		edges = append(edges, share.EdgeNode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShareMutation) EdgeCleared(name string) bool {
	switch name {
	case share.EdgeOwner:
		return m.clearedowner
	case share.EdgeNode:
		return m.clearednode
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShareMutation) ClearEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ClearOwner()
		return nil
	case share.EdgeNode:
		m.ClearNode()
		return nil
	}
	return fmt.Errorf("unknown Share unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShareMutation) ResetEdge(name string) error {
	switch name {
	case share.EdgeOwner:
		m.ResetOwner()
		return nil
	case share.EdgeNode:
		m.ResetNode()
		return nil
	}
	return fmt.Errorf("unknown Share edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	username       *string
	password_hash  *string
	email          *string
	total_quota    *int64
	addtotal_quota *int64
	total_used     *int64
	addtotal_used  *int64
	created_at     *time.Time
	updated_at     *time.Time
	last_login_at  *time.Time
	clearedFields  map[string]struct{}
	nodes          map[int]struct{}
	removednodes   map[int]struct{}
	clearednodes   bool
	shares         map[int]struct{}
	removedshares  map[int]struct{}
	clearedshares  bool
	done           bool
	oldValue       func(context.Context) (*User, error)
	predicates     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetTotalQuota sets the "total_quota" field.
func (m *UserMutation) SetTotalQuota(i int64) {
	m.total_quota = &i
	m.addtotal_quota = nil
}

// TotalQuota returns the value of the "total_quota" field in the mutation.
func (m *UserMutation) TotalQuota() (r int64, exists bool) {
	v := m.total_quota
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalQuota returns the old "total_quota" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotalQuota(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalQuota is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalQuota requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalQuota: %w", err)
	}
	return oldValue.TotalQuota, nil
}

// AddTotalQuota adds i to the "total_quota" field.
func (m *UserMutation) AddTotalQuota(i int64) {
	if m.addtotal_quota != nil {
		*m.addtotal_quota += i
	} else {
		m.addtotal_quota = &i
	}
}

// AddedTotalQuota returns the value that was added to the "total_quota" field in this mutation.
func (m *UserMutation) AddedTotalQuota() (r int64, exists bool) {
	v := m.addtotal_quota
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalQuota resets all changes to the "total_quota" field.
func (m *UserMutation) ResetTotalQuota() {
	m.total_quota = nil
	m.addtotal_quota = nil
}

// SetTotalUsed sets the "total_used" field.
func (m *UserMutation) SetTotalUsed(i int64) {
	m.total_used = &i
	m.addtotal_used = nil
}

// TotalUsed returns the value of the "total_used" field in the mutation.
func (m *UserMutation) TotalUsed() (r int64, exists bool) {
	v := m.total_used
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalUsed returns the old "total_used" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotalUsed(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalUsed: %w", err)
	}
	return oldValue.TotalUsed, nil
}

// AddTotalUsed adds i to the "total_used" field.
func (m *UserMutation) AddTotalUsed(i int64) {
	if m.addtotal_used != nil {
		*m.addtotal_used += i
	} else {
		m.addtotal_used = &i
	}
}

// AddedTotalUsed returns the value that was added to the "total_used" field in this mutation.
func (m *UserMutation) AddedTotalUsed() (r int64, exists bool) {
	v := m.addtotal_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalUsed resets all changes to the "total_used" field.
func (m *UserMutation) ResetTotalUsed() {
	m.total_used = nil
	m.addtotal_used = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// AddNodeIDs adds the "nodes" edge to the Node entity by ids.
func (m *UserMutation) AddNodeIDs(ids ...int) {
	if m.nodes == nil {
		m.nodes = make(map[int]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the Node entity.
func (m *UserMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the Node entity was cleared.
func (m *UserMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the Node entity by IDs.
func (m *UserMutation) RemoveNodeIDs(ids ...int) {
	if m.removednodes == nil {
		m.removednodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the Node entity.
func (m *UserMutation) RemovedNodesIDs() (ids []int) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *UserMutation) NodesIDs() (ids []int) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *UserMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// AddShareIDs adds the "shares" edge to the Share entity by ids.
func (m *UserMutation) AddShareIDs(ids ...int) {
	if m.shares == nil {
		m.shares = make(map[int]struct{})
	}
	for i := range ids {
		m.shares[ids[i]] = struct{}{}
	}
}

// ClearShares clears the "shares" edge to the Share entity.
func (m *UserMutation) ClearShares() {
	m.clearedshares = true
}

// SharesCleared reports if the "shares" edge to the Share entity was cleared.
func (m *UserMutation) SharesCleared() bool {
	return m.clearedshares
}

// RemoveShareIDs removes the "shares" edge to the Share entity by IDs.
func (m *UserMutation) RemoveShareIDs(ids ...int) {
	if m.removedshares == nil {
		m.removedshares = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shares, ids[i])
		m.removedshares[ids[i]] = struct{}{}
	}
}

// RemovedShares returns the removed IDs of the "shares" edge to the Share entity.
func (m *UserMutation) RemovedSharesIDs() (ids []int) {
	for id := range m.removedshares {
		ids = append(ids, id)
	}
	return
}

// SharesIDs returns the "shares" edge IDs in the mutation.
func (m *UserMutation) SharesIDs() (ids []int) {
	for id := range m.shares {
		ids = append(ids, id)
	}
	return
}

// ResetShares resets all changes to the "shares" edge.
func (m *UserMutation) ResetShares() {
	m.shares = nil
	m.clearedshares = false
	m.removedshares = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.total_quota != nil {
		fields = append(fields, user.FieldTotalQuota)
	}
	if m.total_used != nil {
		fields = append(fields, user.FieldTotalUsed)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmail:
		return m.Email()
	case user.FieldTotalQuota:
		return m.TotalQuota()
	case user.FieldTotalUsed:
		return m.TotalUsed()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldTotalQuota:
		return m.OldTotalQuota(ctx)
	case user.FieldTotalUsed:
		return m.OldTotalUsed(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldTotalQuota:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalQuota(v)
		return nil
	case user.FieldTotalUsed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalUsed(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_quota != nil {
		fields = append(fields, user.FieldTotalQuota)
	}
	if m.addtotal_used != nil {
		fields = append(fields, user.FieldTotalUsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTotalQuota:
		return m.AddedTotalQuota()
	case user.FieldTotalUsed:
		return m.AddedTotalUsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTotalQuota:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalQuota(v)
		return nil
	case user.FieldTotalUsed:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalUsed(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldTotalQuota:
		m.ResetTotalQuota()
		return nil
	case user.FieldTotalUsed:
		m.ResetTotalUsed()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.nodes != nil {
		edges = append(edges, user.EdgeNodes)
	}
	if m.shares != nil {
		edges = append(edges, user.EdgeShares)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShares:
		ids := make([]ent.Value, 0, len(m.shares))
		for id := range m.shares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednodes != nil {
		edges = append(edges, user.EdgeNodes)
	}
	if m.removedshares != nil {
		edges = append(edges, user.EdgeShares)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShares:
		ids := make([]ent.Value, 0, len(m.removedshares))
		for id := range m.removedshares {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednodes {
		edges = append(edges, user.EdgeNodes)
	}
	if m.clearedshares {
		edges = append(edges, user.EdgeShares)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeNodes:
		return m.clearednodes
	case user.EdgeShares:
		return m.clearedshares
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeNodes:
		m.ResetNodes()
		return nil
	case user.EdgeShares:
		m.ResetShares()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
